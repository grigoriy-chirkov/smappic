// ========== Copyright Header Begin ============================================
// Copyright (c) 2023 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ========== Copyright Header End ============================================


`include "axi_defines.vh"
`include "define.tmp.h"

<%
from pyhplib import *
%>

module multichip_adapter_inpipe2 (
    input clk,
    input rst_n,

    // Noc interface
    output  wire                                   noc_val,
    output  wire [`NOC_DATA_WIDTH-1:0]             noc_data,
    input   wire                                   noc_rdy,

    // CEP interace
    input  wire                                    cep_val,
    input  wire  [`CEP_DATA_WIDTH-1:0]             cep_data,
    output wire                                    cep_rdy,

    output wire                                   mshr_out_write_en,
    output wire [`MA_MSHR_INDEX_WIDTH-1:0]        mshr_out_write_index,
    output wire [`MA_MSHR_ARRAY_WIDTH-1:0]        mshr_out_write_data,
    output wire [`MA_MSHR_INDEX_WIDTH-1:0]        mshr_out_read_index,
    input  wire [`MA_MSHR_ARRAY_WIDTH-1:0]        mshr_out_read_data,
    input  wire [`MA_MSHR_STATE_BITS-1:0]         mshr_out_read_state,

    input  wire [`MA_MSHR_INDEX_WIDTH-1:0]        mshr_in_empty_index,
    input  wire [`MA_MSHR_INDEX_WIDTH:0]          mshr_in_empty_slots,
    output wire                                   mshr_in_write_en,
    output wire [`MA_MSHR_INDEX_WIDTH-1:0]        mshr_in_write_index,
    output wire [`MA_MSHR_ARRAY_WIDTH-1:0]        mshr_in_write_data, 
    input  wire                                   stall_mshr_in_from_p3
);


wire stall_S1;
wire stall_S2;
wire stall_S3;

wire val_S1;
reg val_S2;
reg val_S3;

// Stage 1

wire val_S2_next = val_S1 & ~stall_S1;
wire [`CEP_DATA_WIDTH-1:0]  data_S1 = cep_data;
wire [`CEP_DATA_WIDTH-1:0] data_S2_next = data_S1;
assign val_S1 = cep_val;
assign cep_rdy = ~stall_S1;
assign stall_S1 = stall_S2 & val_S1;

// Stage 1-> 2

reg [`CEP_DATA_WIDTH-1:0] data_S2;
always @(posedge clk) begin
    if (~rst_n) begin
        val_S2 <= 1'b0;
        data_S2 <= `CEP_DATA_WIDTH'b0;
    end
    else if (~stall_S2) begin
        val_S2 <= val_S2_next;
        data_S2 <= data_S2_next;
    end
end


// Stage 2

wire val_S3_next = val_S2 & ~stall_S2;
wire [`MSG_MSHRID_WIDTH-1:0] msg_mshrid = data_S2[`MSG_MSHRID];
wire [`MSG_TYPE_WIDTH-1:0] msg_type = data_S2[`MSG_TYPE];
wire do_read_mshr = (msg_type != `MSG_TYPE_LOAD_FWD)    & 
                    (msg_type != `MSG_TYPE_STORE_FWD)   &
                    (msg_type != `MSG_TYPE_INV_FWD)     &
                    (msg_type != `MSG_TYPE_LOAD_MEM)    &
                    (msg_type != `MSG_TYPE_STORE_MEM)   &
                    (msg_type != `MSG_TYPE_NC_LOAD_MEM) &
                    (msg_type != `MSG_TYPE_NC_STORE_MEM);
assign mshr_out_write_en = val_S2 & ~stall_S2 & do_read_mshr;
assign mshr_out_write_index = msg_mshrid[`MA_MSHR_INDEX_WIDTH-1:0];
assign mshr_out_write_data = `MA_MSHR_ARRAY_WIDTH'b0;
assign mshr_out_read_index = msg_mshrid[`MA_MSHR_INDEX_WIDTH-1:0];
wire [`MSG_MSHRID_WIDTH-1:0] src_mshrid;
wire [`MSG_SRC_CHIPID_WIDTH-1:0] src_chipid;
wire [`MSG_SRC_X_WIDTH-1:0] src_x;
wire [`MSG_SRC_Y_WIDTH-1:0] src_y;
wire [`MSG_SRC_FBITS_WIDTH-1:0] src_fbits;

multichip_adapter_mshr_decoder mshr_decoder(
    .data(mshr_out_read_data),

    .addr(),
    .way(),
    .mshrid(src_mshrid),
    .cache_type(),
    .data_size(),
    .msg_type(),
    .msg_l2_miss(),
    .src_chipid(src_chipid),
    .src_x(src_x),
    .src_y(src_y),
    .src_fbits(src_fbits),
    .sdid(),
    .lsid(),
    .miss_lsid(),
    .smc_miss(),
    .recycled(),
    .inv_fwd_pending()
);

wire do_write_mshr = (msg_type != `MSG_TYPE_LOAD_FWD)   & 
                     (msg_type != `MSG_TYPE_STORE_FWD)  & 
                     (msg_type != `MSG_TYPE_INV_FWD)    & 
                     (msg_type != `MSG_TYPE_NODATA_ACK) & 
                     (msg_type != `MSG_TYPE_DATA_ACK)   ;
assign mshr_in_write_en = val_S2 & ~stall_S2 & do_write_mshr;
assign mshr_in_write_index = mshr_in_empty_index;

wire stall_mshr_in_full = (mshr_in_empty_slots == {`MA_MSHR_INDEX_WIDTH+1{1'b0}});
wire stall_mshr = do_write_mshr & (stall_mshr_in_full | stall_mshr_in_from_p3);

multichip_adapter_mshr_encoder mshr_encoder(
    .data(mshr_in_write_data),

    .addr(data_S2[`MSG_ADDR]),
    .way(`MA_WAYS_WIDTH'd0),
    .mshrid(data_S2[`MSG_MSHRID]),
    .cache_type(data_S2[`MSG_CACHE_TYPE]),
    .data_size(data_S2[`MSG_DATA_SIZE]),
    .msg_type(data_S2[`MSG_TYPE]),
    .msg_l2_miss(data_S2[`MSG_L2_MISS]),
    .src_chipid(data_S2[`MSG_SRC_CHIPID]),
    .src_x(data_S2[`MSG_SRC_X]),
    .src_y(data_S2[`MSG_SRC_Y]),
    .src_fbits(data_S2[`MSG_SRC_FBITS]),
    .sdid(data_S2[`MSG_SDID]),
    .lsid(data_S2[`MSG_LSID]),
    .miss_lsid(`MSG_LSID_WIDTH'd0),
    .smc_miss(1'b0),
    .recycled(1'b0),
    .inv_fwd_pending(1'b0)
);

reg [`PKG_DATA_WIDTH-1:0] data_S3_next;
always @(*) begin
    data_S3_next = data_S2;
    if (do_write_mshr)
        data_S3_next[`MSG_MSHRID] = {{`MSG_MSHRID_WIDTH-`MA_MSHR_INDEX_WIDTH{1'b0}}, mshr_in_empty_index};
    if (do_read_mshr) begin
        data_S3_next[`MSG_MSHRID] = src_mshrid;
        data_S3_next[`MSG_DST_CHIPID] = src_chipid;
        data_S3_next[`MSG_DST_X] = src_x;
        data_S3_next[`MSG_DST_Y] = src_y;
        data_S3_next[`MSG_DST_FBITS] = src_fbits;
    end
end
assign stall_S2 = val_S2 & (stall_S3 | stall_mshr);

// Stage 2-> 3

reg [`CEP_DATA_WIDTH-1:0] data_S3;
always @(posedge clk) begin
    if (~rst_n) begin
        val_S3 <= 1'b0;
        data_S3 <= `CEP_DATA_WIDTH'b0;
    end
    else if (~stall_S3) begin
        val_S3 <= val_S3_next;
        data_S3 <= data_S3_next;
    end
end


wire pkg_rdy;

noc_serializer noc_serializer(
    .clk(clk),
    .rst_n(rst_n),

    .flit_val(noc_val),
    .flit_data(noc_data),
    .flit_rdy(noc_rdy),

    .pkg_val(val_S3), 
    .pkg_data(data_S3),
    .pkg_rdy(pkg_rdy)
);

assign stall_S3 = ~pkg_rdy & val_S3;

endmodule