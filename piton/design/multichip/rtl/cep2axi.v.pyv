// ========== Copyright Header Begin ============================================
// Copyright (c) 2023 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ========== Copyright Header End ============================================

`include "axi_defines.vh"
`include "define.tmp.h"

<%
from pyhplib import *
%>


module cep2axi (
    input axi_clk,
    input axi_rst_n,
    input sys_clk, 
    input sys_rst_n,
    
    // CEP interface
    input  wire                               cep_queue1_val,
    input  wire  [`CEP_DATA_WIDTH-1:0]        cep_queue1_data,
    input  wire  [`NOC_CHIPID_WIDTH-1:0]      cep_queue1_chipid,
    output wire                               cep_queue1_rdy, 
    input  wire                               cep_queue2_val,
    input  wire  [`CEP_DATA_WIDTH-1:0]        cep_queue2_data,
    input  wire  [`NOC_CHIPID_WIDTH-1:0]      cep_queue2_chipid,
    output wire                               cep_queue2_rdy,
    input  wire                               cep_queue3_val,
    input  wire  [`CEP_DATA_WIDTH-1:0]        cep_queue3_data,
    input  wire  [`NOC_CHIPID_WIDTH-1:0]      cep_queue3_chipid,
    output wire                               cep_queue3_rdy,

    // AXI interace
    output wire [`AXI4_ID_WIDTH     -1:0]     m_axi_awid,
    output reg  [`AXI4_ADDR_WIDTH   -1:0]     m_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]     m_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]     m_axi_awsize,
    output wire [`AXI4_USER_WIDTH   -1:0]     m_axi_awuser,
    output reg                                m_axi_awvalid,
    input  wire                               m_axi_awready,
    output reg   [`AXI4_DATA_WIDTH   -1:0]    m_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    m_axi_wstrb,
    output wire                               m_axi_wlast,
    output reg                                m_axi_wvalid,
    input  wire                               m_axi_wready,
    output wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    m_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    m_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    m_axi_arsize,
    output wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_aruser,
    output wire                               m_axi_arvalid,
    input  wire                               m_axi_arready,
    input  wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    m_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    m_axi_rresp,
    input  wire                               m_axi_rlast,
    input  wire                               m_axi_rvalid,
    output wire                               m_axi_rready,
    input  wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    m_axi_bresp,
    input  wire                               m_axi_bvalid,
    output wire                               m_axi_bready, 

    input wire   [`NOC_CHIPID_WIDTH-1:0]      chipid, 
<%
for i in range(PITON_NUM_CHIPS):
    print(f"    input wire   [`AXI4_ADDR_WIDTH-1:0]       chip{i}_base, ")
%>
    input wire   [`AXI4_ADDR_WIDTH-1:0]       host_base
);

// sync cep to axi clock

wire cep_queue1_val_synced;
wire [`CEP_DATA_WIDTH-1:0] cep_queue1_data_synced;
wire [`NOC_CHIPID_WIDTH-1:0] cep_queue1_chipid_synced;
reg  cep_queue1_rdy_synced;
wire [`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH-1:0] fifo1_out;
wire fifo1_full;
wire fifo1_empty;

`ifdef PITON_PROTO
afifo_w526_d16  clk_crossing_fifo1(
    .rst(~sys_rst_n),
    .wr_clk(sys_clk),
    .rd_clk(axi_clk),
    .rd_en(cep_queue1_rdy_synced),
    .wr_en(cep_queue1_val),
    .din({cep_queue1_chipid, cep_queue1_data}),
    .dout(fifo1_out),
    .full(fifo1_full),
    .empty(fifo1_empty)
);
`else // ifndef PITON_PROTO
async_fifo #(
.DSIZE(`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH),
.ASIZE(4),
.MEMSIZE(8) )
clk_crossing_fifo1(
    .rreset(~axi_rst_n),
    .wreset(~sys_rst_n),
    .wclk(sys_clk),
    .rclk(axi_clk),
    .ren(cep_queue1_rdy_synced),
    .wval(cep_queue1_val),
    .wdata({cep_queue1_chipid, cep_queue1_data}),
    .rdata(fifo1_out),
    .wfull(fifo1_full),
    .rempty(fifo1_empty)
);
`endif // endif PITON_PROTO
assign cep_queue1_rdy = ~fifo1_full;
assign cep_queue1_val_synced = ~fifo1_empty;
assign cep_queue1_data_synced = fifo1_out[`CEP_DATA_WIDTH-1:0];
assign cep_queue1_chipid_synced = fifo1_out[`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH-1:`CEP_DATA_WIDTH];


wire cep_queue2_val_synced;
wire [`CEP_DATA_WIDTH-1:0] cep_queue2_data_synced;
wire [`NOC_CHIPID_WIDTH-1:0] cep_queue2_chipid_synced;
reg  cep_queue2_rdy_synced;
wire [`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH-1:0] fifo2_out;
wire fifo2_full;
wire fifo2_empty;

`ifdef PITON_PROTO
afifo_w526_d16  clk_crossing_fifo2(
    .rst(~sys_rst_n),
    .wr_clk(sys_clk),
    .rd_clk(axi_clk),
    .rd_en(cep_queue2_rdy_synced),
    .wr_en(cep_queue2_val),
    .din({cep_queue2_chipid, cep_queue2_data}),
    .dout(fifo2_out),
    .full(fifo2_full),
    .empty(fifo2_empty)
);
`else // ifndef PITON_PROTO
async_fifo #(
.DSIZE(`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH),
.ASIZE(4),
.MEMSIZE(8) )
clk_crossing_fifo2(
    .rreset(~axi_rst_n),
    .wreset(~sys_rst_n),
    .wclk(sys_clk),
    .rclk(axi_clk),
    .ren(cep_queue2_rdy_synced),
    .wval(cep_queue2_val),
    .wdata({cep_queue2_chipid, cep_queue2_data}),
    .rdata(fifo2_out),
    .wfull(fifo2_full),
    .rempty(fifo2_empty)
);
`endif // endif PITON_PROTO
assign cep_queue2_rdy = ~fifo2_full;
assign cep_queue2_val_synced = ~fifo2_empty;
assign cep_queue2_data_synced = fifo2_out[`CEP_DATA_WIDTH-1:0];
assign cep_queue2_chipid_synced = fifo2_out[`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH-1:`CEP_DATA_WIDTH];

wire cep_queue3_val_synced;
wire [`CEP_DATA_WIDTH-1:0] cep_queue3_data_synced;
wire [`NOC_CHIPID_WIDTH-1:0] cep_queue3_chipid_synced;
reg  cep_queue3_rdy_synced;
wire [`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH-1:0] fifo3_out;
wire fifo3_full;
wire fifo3_empty;

`ifdef PITON_PROTO
afifo_w526_d16  clk_crossing_fifo3(
    .rst(~sys_rst_n),
    .wr_clk(sys_clk),
    .rd_clk(axi_clk),
    .rd_en(cep_queue3_rdy_synced),
    .wr_en(cep_queue3_val),
    .din({cep_queue3_chipid, cep_queue3_data}),
    .dout(fifo3_out),
    .full(fifo3_full),
    .empty(fifo3_empty)
);
`else // ifndef PITON_PROTO
async_fifo #(
.DSIZE(`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH),
.ASIZE(4),
.MEMSIZE(8) )
clk_crossing_fifo3(
    .rreset(~axi_rst_n),
    .wreset(~sys_rst_n),
    .wclk(sys_clk),
    .rclk(axi_clk),
    .ren(cep_queue3_rdy_synced),
    .wval(cep_queue3_val),
    .wdata({cep_queue3_chipid, cep_queue3_data}),
    .rdata(fifo3_out),
    .wfull(fifo3_full),
    .rempty(fifo3_empty)
);
`endif // endif PITON_PROTO
assign cep_queue3_rdy = ~fifo3_full;
assign cep_queue3_val_synced = ~fifo3_empty;
assign cep_queue3_data_synced = fifo3_out[`CEP_DATA_WIDTH-1:0];
assign cep_queue3_chipid_synced = fifo3_out[`CEP_DATA_WIDTH+`NOC_CHIPID_WIDTH-1:`CEP_DATA_WIDTH];



//=========================================
// choose which queue goes now
//=========================================

<%
print(f'''
wire [{PITON_NUM_CHIPS}:0] cep_queue1_credits_nz;
wire [{PITON_NUM_CHIPS}:0] cep_queue2_credits_nz;
wire [{PITON_NUM_CHIPS}:0] cep_queue3_credits_nz;
''')
%>

reg [2:0] queue_chosen;
always @(*) begin
  // always choose queue3 if its valid and we have
  // enough credits to send to destination
  queue_chosen[2] = cep_queue3_val_synced & 
                    cep_queue3_credits_nz[cep_queue3_chipid_synced];
  // choose queue2 if queue 3 is not chosen,
  // and we have enough credits
  queue_chosen[1] = cep_queue2_val_synced & ~queue_chosen[2] & 
                    cep_queue2_credits_nz[cep_queue2_chipid_synced];
  // same logic for queue1, but with even lower priority
  queue_chosen[0] = cep_queue1_val_synced & ~queue_chosen[2] & ~queue_chosen[1] & 
                    cep_queue1_credits_nz[cep_queue1_chipid_synced];
end

reg cep_val_synced;
reg [`CEP_DATA_WIDTH-1:0] cep_data_synced;
reg [2:0] cep_queue_id_synced;
reg [`NOC_CHIPID_WIDTH-1:0] cep_chipid_synced;
wire cep_rdy_synced;

always @* begin
    case (queue_chosen) 
        3'b001: begin
            cep_val_synced = cep_queue1_val_synced;
            cep_data_synced = cep_queue1_data_synced;
            cep_queue_id_synced = 3'b001;
            cep_chipid_synced = cep_queue1_chipid_synced;
            cep_queue1_rdy_synced = cep_rdy_synced;
            cep_queue2_rdy_synced = 1'b0;
            cep_queue3_rdy_synced = 1'b0;
        end
        3'b010: begin
            cep_val_synced = cep_queue2_val_synced;
            cep_data_synced = cep_queue2_data_synced;
            cep_queue_id_synced = 3'b010;
            cep_chipid_synced = cep_queue2_chipid_synced;
            cep_queue1_rdy_synced = 1'b0;
            cep_queue2_rdy_synced = cep_rdy_synced;
            cep_queue3_rdy_synced = 1'b0;
        end
        3'b100: begin
            cep_val_synced = cep_queue3_val_synced;
            cep_data_synced = cep_queue3_data_synced;
            cep_queue_id_synced = 3'b100;
            cep_chipid_synced = cep_queue3_chipid_synced;
            cep_queue1_rdy_synced = 1'b0;
            cep_queue2_rdy_synced = 1'b0;
            cep_queue3_rdy_synced = cep_rdy_synced;
        end
        default: begin
            // no queue is chosen
            cep_val_synced = 1'b0;
            cep_data_synced = `CEP_DATA_WIDTH'd0;
            cep_queue_id_synced = 3'b000;
            cep_chipid_synced = `NOC_CHIPID_WIDTH'b0;
            cep_queue1_rdy_synced = 1'b0;
            cep_queue2_rdy_synced = 1'b0;
            cep_queue3_rdy_synced = 1'b0;
        end
    endcase
end

wire axi_aw_go = m_axi_awvalid & m_axi_awready;
wire axi_w_go  = m_axi_wvalid  & m_axi_wready;

wire [`AXI4_DATA_WIDTH-1:0] wdata = cep_data_synced;
reg [`AXI4_ADDR_WIDTH-1:0] wr_addr;
reg [`NOC_CHIPID_WIDTH-1:0] wr_chipid;
always @(*) begin
  wr_chipid = cep_chipid_synced;
<%
print(f'''
  if (wr_chipid > {PITON_NUM_CHIPS}) wr_chipid = `NOC_CHIPID_WIDTH'd{PITON_NUM_CHIPS};
''')
%>
  case (wr_chipid)
<%
for i in range(PITON_NUM_CHIPS):
    print(f"    {i}       : wr_addr = chip{i}_base;")
%>
    default : wr_addr = host_base;
  endcase
  wr_addr[8:6] = cep_queue_id_synced;
  wr_addr[13:9] = chipid;
end

assign cep_rdy_synced = (m_axi_awready | ~m_axi_awvalid) & (m_axi_wready | ~m_axi_wvalid);
wire wr_dispatch = cep_val_synced & cep_rdy_synced;


// const fields
assign m_axi_awid = 6'b100000;
assign m_axi_bready   = 1'b1;
assign m_axi_awlen    = `AXI4_LEN_WIDTH'b0;
assign m_axi_awsize   = `AXI4_SIZE_WIDTH'b110;
assign m_axi_awuser   = `AXI4_USER_WIDTH'b0;
assign m_axi_wstrb = `AXI4_STRB_WIDTH'hffffffffffffffff;
assign m_axi_wlast   = 1'b1;


always @(posedge axi_clk) begin
    if(~axi_rst_n) begin
        m_axi_awaddr <= `AXI4_ADDR_WIDTH'b0;
        m_axi_awvalid <= 1'b0;
        m_axi_wdata <= `AXI4_DATA_WIDTH'h0;
        m_axi_wvalid <= 1'b0;
    end
    else begin
        if (wr_dispatch) begin
            m_axi_awaddr <= wr_addr;
            m_axi_awvalid <= 1'b1;
            m_axi_wvalid <= 1'b1;
            m_axi_wdata <= wdata;
        end
        else begin
            if (axi_aw_go) begin
                m_axi_awvalid <= 1'b0;
            end
            if (axi_w_go) begin
                m_axi_wvalid <= 1'b0;
            end
        end
    end
end



// credit counting
cep2axi_credits cep2axi_credits(
    .axi_clk       (axi_clk), 
    .axi_rst_n     (axi_rst_n), 

    .cep_queue1_credits_nz   (cep_queue1_credits_nz), 
    .cep_queue2_credits_nz   (cep_queue2_credits_nz), 
    .cep_queue3_credits_nz   (cep_queue3_credits_nz), 

    .wr_dispatch   (wr_dispatch),
    .wr_chipid     (wr_chipid), 
    .wr_queue_id   (cep_queue_id_synced),

    .m_axi_arid    (m_axi_arid), 
    .m_axi_araddr  (m_axi_araddr), 
    .m_axi_arlen   (m_axi_arlen), 
    .m_axi_arsize  (m_axi_arsize), 
    .m_axi_aruser  (m_axi_aruser), 
    .m_axi_arvalid (m_axi_arvalid), 
    .m_axi_arready (m_axi_arready), 
    .m_axi_rid     (m_axi_rid), 
    .m_axi_rdata   (m_axi_rdata), 
    .m_axi_rresp   (m_axi_rresp), 
    .m_axi_rlast   (m_axi_rlast), 
    .m_axi_rvalid  (m_axi_rvalid), 
    .m_axi_rready  (m_axi_rready), 

    .chipid        (chipid), 
<%
for i in range(PITON_NUM_CHIPS):
    print(f"    .chip{i}_base    (chip{i}_base), ")
%>
    .host_base     (host_base)
);


// `ifdef PITON_FPGA_SYNTH
// ila_1 noc2axi_axi_ila (
//     .axi_clk(axi_clk),
//     .probe0(m_axi_wready),
//     .probe1( m_axi_awaddr),
//     .probe2( m_axi_bresp),
//     .probe3( m_axi_bvalid),
//     .probe4( m_axi_bready),
//     .probe5( m_axi_araddr),
//     .probe6( m_axi_rready),
//     .probe7( m_axi_wvalid),
//     .probe8( m_axi_arvalid),
//     .probe9( m_axi_arready),
//     .probe10( m_axi_rdata),
//     .probe11( m_axi_awvalid),
//     .probe12( m_axi_awready),
//     .probe13( m_axi_rresp),
//     .probe14( m_axi_wdata),
//     .probe15( m_axi_wstrb),
//     .probe16( m_axi_rvalid),
//     .probe19( m_axi_awid),
//     .probe20( m_axi_bid),
//     .probe21(credits1_nz), 
//     .probe22(credits2_nz), 
//     .probe23(credits3_nz),
//     .probe25( m_axi_arid),
//     .probe38( m_axi_rid),
//     .probe41( m_axi_rlast),
//     .probe43( m_axi_wlast)
// );
// `endif



endmodule