// ========== Copyright Header Begin ============================================
// Copyright (c) 2023 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ========== Copyright Header End ============================================


`include "axi_defines.vh"
`include "define.tmp.h"

<%
from pyhplib import *
%>

module cep2noc (
    input clk,
    input rst_n,
    input   wire [`NOC_CHIPID_WIDTH-1:0]           fpgaid,

    // Noc interface
    output  wire                                   noc1_val,
    output  wire [`NOC_DATA_WIDTH-1:0]             noc1_data,
    input   wire                                   noc1_rdy,
    output  wire                                   noc2_val,
    output  wire [`NOC_DATA_WIDTH-1:0]             noc2_data,
    input   wire                                   noc2_rdy,
    output  wire                                   noc3_val,
    output  wire [`NOC_DATA_WIDTH-1:0]             noc3_data,
    input   wire                                   noc3_rdy,

    // CEP interace
    input  wire                                    cep_val,
    input  wire  [`CEP_DATA_WIDTH-1:0]             cep_data,
    input  wire  [2:0]                             cep_queue_id,
    input  wire  [`NOC_CHIPID_WIDTH-1:0]           cep_chipid,
    output wire                                    cep_rdy, 
    // credits
<%
print(f'''
    output wire [{PITON_NUM_CHIPS}:0]              cep_queue1_credits, 
    output wire [{PITON_NUM_CHIPS}:0]              cep_queue2_credits, 
    output wire [{PITON_NUM_CHIPS}:0]              cep_queue3_credits
''')
%>
);

assign cep_rdy = 1'b1;

wire cep_queue1_val;
wire [`CEP_DATA_WIDTH-1:0] cep_queue1_data;
wire cep_queue1_rdy;
cep2noc_queue queue1 (
    .clk(clk),
    .rst_n(rst_n),
    .fpgaid(fpgaid),

    //input
<%
for i in range(PITON_NUM_CHIPS):
    print(f'''\
    .chip{i}_cep_val_in(cep_val & (cep_chipid == {i}) & cep_queue_id[0]),
''')
print(f'''\
    .host_cep_val_in(cep_val & (cep_chipid >= {PITON_NUM_CHIPS}) & cep_queue_id[0]),
''')
%>
    .cep_data_in(cep_data),

    //output
    .cep_val_out(cep_queue1_val),
    .cep_data_out(cep_queue1_data),
    .cep_rdy_out(cep_queue1_rdy),
    .cep_credits(cep_queue1_credits)
);

wire cep_queue2_val;
wire [`CEP_DATA_WIDTH-1:0] cep_queue2_data;
wire cep_queue2_rdy;
cep2noc_queue queue2 (
    .clk(clk),
    .rst_n(rst_n),
    .fpgaid(fpgaid),

    // input
<%
for i in range(PITON_NUM_CHIPS):
    print(f'''\
    .chip{i}_cep_val_in(cep_val & (cep_chipid == {i}) & cep_queue_id[1]),
''')
print(f'''\
    .host_cep_val_in(cep_val & (cep_chipid >= {PITON_NUM_CHIPS}) & cep_queue_id[1]),
''')
%>
    .cep_data_in(cep_data),

    //output
    .cep_val_out(cep_queue2_val),
    .cep_data_out(cep_queue2_data),
    .cep_rdy_out(cep_queue2_rdy),
    .cep_credits(cep_queue2_credits)
);

wire cep_queue3_val;
wire [`CEP_DATA_WIDTH-1:0] cep_queue3_data;
wire cep_queue3_rdy;
cep2noc_queue queue3 (
    .clk(clk),
    .rst_n(rst_n),
    .fpgaid(fpgaid),

    // input
<%
for i in range(PITON_NUM_CHIPS):
    print(f'''\
    .chip{i}_cep_val_in(cep_val & (cep_chipid == {i}) & cep_queue_id[2]),
''')
print(f'''\
    .host_cep_val_in(cep_val & (cep_chipid >= {PITON_NUM_CHIPS}) & cep_queue_id[2]),
''')
%>
    .cep_data_in(cep_data),

    // output
    .cep_val_out(cep_queue3_val),
    .cep_data_out(cep_queue3_data),
    .cep_rdy_out(cep_queue3_rdy),
    .cep_credits(cep_queue3_credits)
);

wire pkg1_val;
wire [`PKG_DATA_WIDTH-1:0] pkg1_data;
wire pkg1_rdy;
wire pkg2_val;
wire [`PKG_DATA_WIDTH-1:0] pkg2_data;
wire pkg2_rdy;
wire pkg3_val;
wire [`PKG_DATA_WIDTH-1:0] pkg3_data;
wire pkg3_rdy;

cep2pkg cep2pkg(
    .clk(clk),
    .rst_n(rst_n),

    .pkg1_val(pkg1_val),
    .pkg1_data(pkg1_data),
    .pkg1_rdy(pkg1_rdy),
    .pkg2_val(pkg2_val),
    .pkg2_data(pkg2_data),
    .pkg2_rdy(pkg2_rdy),
    .pkg3_val(pkg3_val),
    .pkg3_data(pkg3_data),
    .pkg3_rdy(pkg3_rdy),

    .cep_queue1_val(cep_queue1_val),
    .cep_queue1_data(cep_queue1_data), 
    .cep_queue1_rdy(cep_queue1_rdy),
    .cep_queue2_val(cep_queue2_val),
    .cep_queue2_data(cep_queue2_data), 
    .cep_queue2_rdy(cep_queue2_rdy),
    .cep_queue3_val(cep_queue3_val),
    .cep_queue3_data(cep_queue3_data), 
    .cep_queue3_rdy(cep_queue3_rdy)
);


noc_serializer noc1_serializer(
    .clk(clk),
    .rst_n(rst_n),

    .flit_val(noc1_val),
    .flit_data(noc1_data),
    .flit_rdy(noc1_rdy),

    .pkg_val(pkg1_val), 
    .pkg_data(pkg1_data),
    .pkg_rdy(pkg1_rdy)
);

noc_serializer noc2_serializer(
    .clk(clk),
    .rst_n(rst_n),

    .flit_val(noc2_val),
    .flit_data(noc2_data),
    .flit_rdy(noc2_rdy),

    .pkg_val(pkg2_val), 
    .pkg_data(pkg2_data),
    .pkg_rdy(pkg2_rdy)
);

noc_serializer noc3_serializer(
    .clk(clk),
    .rst_n(rst_n),

    .flit_val(noc3_val),
    .flit_data(noc3_data),
    .flit_rdy(noc3_rdy),

    .pkg_val(pkg3_val), 
    .pkg_data(pkg3_data),
    .pkg_rdy(pkg3_rdy)
);

endmodule