// ========== Copyright Header Begin ============================================
// Copyright (c) 2023 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ========== Copyright Header End ============================================

`include "cep_defines.vh"
`include "define.tmp.h"

<%
from pyhplib import *
%>


module multichip_adapter_outpipe1 (
    input clk,
    input rst_n,
    input [`CEP_CHIPID_WIDTH-1:0]                 mychipid,
    
    // Noc interface
    input  wire                                   noc_val,
    input  wire [`NOC_DATA_WIDTH-1:0]             noc_data,
    output wire                                   noc_rdy,

    // CEP interace
    output wire                                   cep_val,
    output wire [`CEP_DATA_WIDTH-1:0]             cep_data,
    output wire [`CEP_CHIPID_WIDTH-1:0]           cep_chipid,
    input  wire                                   cep_rdy,

    input  wire [`MA_MSHR_INDEX_WIDTH-1:0]        mshr_empty_index,
    input  wire [`MA_MSHR_INDEX_WIDTH:0]          mshr_empty_slots,
    output wire                                   mshr_write_en,
    output wire [`MA_MSHR_INDEX_WIDTH-1:0]        mshr_write_index,
    output wire [`MA_MSHR_ARRAY_WIDTH-1:0]        mshr_write_data, 
    input  wire                                   stall_mshr_from_p2,

    // Dir interface
    output wire                                   dir_rd_en,
    output wire [`MA_ADDR_WIDTH-1:0]              dir_rd_addr,
    input  wire                                   dir_rd_hit,
    input  wire [`MA_SET_WIDTH-1:0]               dir_rd_set,
    input  wire [`MA_WAY_WIDTH-1:0]               dir_rd_way,
    input  wire [`MA_TAG_WIDTH-1:0]               dir_rd_tag,
    input  wire [`MA_STATE_WIDTH-1:0]             dir_rd_state,
    input  wire                                   dir_rd_shared,
    input  wire [`MA_SHARER_SET_WIDTH-1:0]        dir_rd_sharer_set,
    input  wire [`MA_WAY_WIDTH:0]                 dir_num_empty_ways,
    input  wire [`MA_WAY_WIDTH-1:0]               dir_empty_way,
    input  wire                                   dir_rd_stall_from_p2,

    output wire                                   dir_wr_en,
    output wire [`MA_SET_WIDTH-1:0]               dir_wr_set,
    output wire [`MA_WAY_WIDTH-1:0]               dir_wr_way,
    output wire [`MA_TAG_WIDTH-1:0]               dir_wr_tag,
    output wire [`MA_STATE_WIDTH-1:0]             dir_wr_state,
    output wire [`MA_SHARER_SET_WIDTH-1:0]        dir_wr_sharer_set,
    input  wire                                   dir_wr_stall_from_p2
);




wire stall_S1;
wire stall_S2;
wire stall_S3;

wire val_S1;
reg val_S2;
reg val_S3;

// Stage 1

wire [`PKG_DATA_WIDTH-1:0] data_S1;

noc_deserializer noc_deserializer(
    .clk(clk),
    .rst_n(rst_n),

    .flit_val(noc_val),
    .flit_data(noc_data),
    .flit_rdy(noc_rdy),

    .pkg_val(val_S1), 
    .pkg_data(data_S1),
    .pkg_rdy(~stall_S1)
);


wire val_S2_next = val_S1 & ~stall_S1;
wire [`PKG_DATA_WIDTH-1:0] data_S2_next = data_S1;

wire [`PHY_ADDR_WIDTH-1:0] msg_addr_S1 = data_S1[`MSG_ADDR];
wire [`MSG_TYPE_WIDTH-1:0] msg_type_S1 = data_S1[`MSG_TYPE];
wire int_msg_S1 = (msg_type_S1 == `MSG_TYPE_INTERRUPT_FWD);
wire nc_msg_S1 = (msg_type_S1 == `MSG_TYPE_NC_LOAD_REQ) |
                 (msg_type_S1 == `MSG_TYPE_NC_STORE_REQ);
wire do_rd_tag_S1 = ~nc_msg_S1 & ~int_msg_S1;
assign dir_rd_en = val_S1 & ~stall_S1 & do_rd_tag_S1;
assign dir_rd_addr = msg_addr_S1[`MA_ADDR_WIDTH-1:0];

assign stall_S1 = (stall_S2 | dir_rd_stall_from_p2) & val_S1;


// Stage 1 -> 2

reg [`PKG_DATA_WIDTH-1:0] data_S2;

always @(posedge clk) begin
    if (~rst_n) begin
        val_S2 <= 1'b0;
        data_S2 <= `PKG_DATA_WIDTH'b0;
    end
    else if (~stall_S2) begin
        val_S2 <= val_S2_next;
        data_S2 <= data_S2_next;
    end 
end

// Stage 2

wire val_S3_next = val_S2 & ~stall_S2;
wire [`MSG_TYPE_WIDTH-1:0] msg_type_S2 = data_S2[`MSG_TYPE];
wire [`PHY_ADDR_WIDTH-1:0] msg_addr_S2 = data_S2[`MSG_ADDR];
wire nc_msg_S2 = (msg_type_S2 == `MSG_TYPE_NC_LOAD_REQ ) | 
                 (msg_type_S2 == `MSG_TYPE_NC_STORE_REQ) ;
wire int_msg_S2 = (msg_type_S2 == `MSG_TYPE_INTERRUPT_FWD);
wire do_write_mshr_S2 = ~int_msg_S2;


reg [`PKG_DATA_WIDTH-1:0] data_S3_next;
always @(*) begin
    data_S3_next = data_S2;
    if (do_write_mshr_S2) begin
        data_S3_next[`MSG_MSHRID] = {{`MSG_MSHRID_WIDTH-`MA_MSHR_INDEX_WIDTH{1'b0}}, mshr_empty_index};
        data_S3_next[`MSG_SRC_CHIPID] = mychipid;
        data_S3_next[`MSG_SRC_X] = {`MSG_SRC_X_WIDTH{1'b1}};
        data_S3_next[`MSG_SRC_Y] = {`MSG_SRC_Y_WIDTH{1'b1}};
        data_S3_next[`MSG_SRC_FBITS] = `NOC_FBITS_L1;
    end
end

assign mshr_write_en = val_S2 & ~stall_S2 & do_write_mshr_S2;
assign mshr_write_index = mshr_empty_index;


multichip_adapter_mshr_encoder mshr_encoder(
    .data(mshr_write_data),

    .addr(data_S2[`MSG_ADDR]),
    .way(`MA_WAY_WIDTH'd0),
    .mshrid(data_S2[`MSG_MSHRID]),
    .cache_type(data_S2[`MSG_CACHE_TYPE]),
    .data_size(data_S2[`MSG_DATA_SIZE]),
    .msg_type(data_S2[`MSG_TYPE]),
    .msg_l2_miss(data_S2[`MSG_L2_MISS]),
    .src_chipid(data_S2[`MSG_SRC_CHIPID]),
    .src_x(data_S2[`MSG_SRC_X]),
    .src_y(data_S2[`MSG_SRC_Y]),
    .src_fbits(data_S2[`MSG_SRC_FBITS]),
    .sdid(data_S2[`MSG_SDID]),
    .lsid(data_S2[`MSG_LSID]),
    .miss_lsid(`MSG_LSID_WIDTH'd0),
    .smc_miss(1'b0),
    .recycled(1'b0),
    .inv_fwd_pending(1'b0),
    .data0(`MA_MSHR_DATA_CHUNK_WIDTH'b0),
    .data1(`MA_MSHR_DATA_CHUNK_WIDTH'b0),
    .data2(`MA_MSHR_DATA_CHUNK_WIDTH'b0),
    .data3(`MA_MSHR_DATA_CHUNK_WIDTH'b0)
);

wire do_write_tag_S2 = ~nc_msg_S2 & ~int_msg_S2;
assign dir_wr_en = val_S2 & ~stall_S2 & do_write_tag_S2;
assign dir_wr_set = dir_rd_set;
assign dir_wr_way = dir_rd_hit ? dir_rd_way : dir_empty_way;
assign dir_wr_tag = msg_addr_S2[`MA_ADDR_TAG];
assign dir_wr_state = `MA_STATE_VALID;

wire [`NOC_X_WIDTH-1:0] x_src_S2 = data_S2[`MSG_SRC_X];
wire [`NOC_Y_WIDTH-1:0] y_src_S2 = data_S2[`MSG_SRC_Y];
wire [`HOME_ID_WIDTH-1:0] flat_id_S2;
xy_to_flat_id xy_to_flat_id(
    .x_coord(x_src_S2),
    .y_coord(y_src_S2),
    .flat_id(flat_id_S2)
);
assign dir_wr_sharer_set = dir_rd_hit ? (`MA_SHARER_SET_WIDTH'b1 << flat_id_S2) | dir_rd_sharer_set : (`MA_SHARER_SET_WIDTH'b1 << flat_id_S2);

wire stall_mshr_full_S2 = (mshr_empty_slots == {`MA_MSHR_INDEX_WIDTH+1{1'b0}});
wire stall_mshr_S2 = do_write_mshr_S2 & (stall_mshr_full_S2 | stall_mshr_from_p2);
assign stall_S2 = val_S2 & (stall_S3 | stall_mshr_S2 | dir_wr_stall_from_p2);

// Stage 2 -> 3

reg [`PKG_DATA_WIDTH-1:0] data_S3;

always @(posedge clk) begin
    if (~rst_n) begin
        val_S3 <= 1'b0;
        data_S3 <= `PKG_DATA_WIDTH'b0;
    end
    else if (~stall_S3) begin
        val_S3 <= val_S3_next;
        data_S3 <= data_S3_next;
    end 
end

assign stall_S3 = ~cep_rdy & val_S3;

assign cep_val = val_S3;
assign cep_data = data_S3;
assign cep_chipid = {1'b0, data_S3[`MSG_DST_ONCHIPID]};

// sanity checks

reg dir_full_err;
always @(posedge clk) begin
    if (~rst_n) begin
        dir_full_err <= 1'b0;
    end
    else begin
        dir_full_err <= dir_full_err | (dir_wr_en & ~dir_rd_hit & (dir_num_empty_ways == {`MA_WAY_WIDTH+1{1'b0}}));
    end
end

endmodule